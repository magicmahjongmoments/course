<script src="../../assets/js/MahjongUtils.js"></script>
<script>
class MahjongWallGame {
    constructor() {
        this.totalTiles = 38; // Only tiles for player's wall
        this.tilesPerWall = 38;
        this.stacksPerWall = 19;
        this.tilesPlaced = 0;
        this.stacksBuilt = 0;
        this.wallPositions = Array(19).fill(0); // Track tiles in each stack position
        
        // Bind handlers for drag and drop
        this.dragHandlers = {
            dragStart: this.handleDragStart.bind(this),
            dragOver: this.handleDragOver.bind(this),
            drop: this.handleDrop.bind(this),
            dragEnd: this.handleDragEnd.bind(this)
        };
        
        this.init();
    }

    init() {
        this.createBuiltWalls();
        this.createTiles();
        this.setupEventListeners();
        this.updateStats();
    }

    createBuiltWalls() {
        const walls = [
            { id: 'leftWall', index: 0 },
            { id: 'rightWall', index: 2 }, 
            { id: 'topWall', index: 1 }
        ];
        
        walls.forEach(wall => {
            MahjongUtils.createWall(wall.id, wall.index, 38, true);
        });
    }

    createTiles() {
        const tileCenter = document.getElementById('tileCenter');
        tileCenter.innerHTML = '';
        
        for (let i = 0; i < this.totalTiles; i++) {
            const tile = MahjongUtils.createTile(i.toString(), null, true);
            
            // Position tiles randomly in the center area
            const position = MahjongUtils.getRandomPosition(340, 250);
            tile.style.left = position.x + 'px';
            tile.style.top = position.y + 'px';
            
            tileCenter.appendChild(tile);
        }
    }

    setupEventListeners() {
        MahjongUtils.setupDragAndDrop(this.dragHandlers);
    }

    handleDragStart(e) {
        if (e.target.classList.contains('mahjong-tile') && !e.target.classList.contains('placed')) {
            e.target.classList.add('dragging');
            e.dataTransfer.setData('text/plain', e.target.dataset.tileId);
        }
    }

    handleDragOver(e) {
        if (e.target.id === 'bottomWall') {
            e.preventDefault();
            e.target.classList.add('drag-over');
        }
    }

    handleDrop(e) {
        e.preventDefault();
        if (e.target.id === 'bottomWall') {
            e.target.classList.remove('drag-over');
            const tileId = e.dataTransfer.getData('text/plain');
            const tile = document.querySelector(`[data-tile-id="${tileId}"]`);
            
            if (this.tilesPlaced < this.tilesPerWall) {
                this.placeTileInWall(tile, e.target, e);
            }
        }
    }

    handleDragEnd(e) {
        e.target.classList.remove('dragging');
        document.getElementById('bottomWall').classList.remove('drag-over');
    }

    placeTileInWall(tile, wallArea, dropEvent) {
        // Find the first available stack position
        let stackIndex = this.findNextStackPosition();
        
        // If no available positions, return
        if (stackIndex === -1) {
            return;
        }

        const isTopTile = this.wallPositions[stackIndex] === 1;
        const x = 10 + (stackIndex * 30); // Position within the wall
        const y = isTopTile ? 10 : 30; // Stack vertically within the wall

        // Move the tile to the wall area and position it correctly
        wallArea.appendChild(tile);
        tile.style.position = 'absolute';
        tile.style.left = x + 'px';
        tile.style.top = y + 'px';
        tile.classList.add('placed');
        tile.draggable = false;

        if (isTopTile) {
            tile.classList.add('stacked');
        }
        
        if (navigator.vibrate) navigator.vibrate(50);
        MahjongUtils.playClick();
        tile.classList.add('snap');
        setTimeout(() => tile.classList.remove('snap'), 200);

        this.wallPositions[stackIndex]++;
        this.tilesPlaced++;

        // Update stacks built count
        this.stacksBuilt = this.wallPositions.filter(count => count === 2).length;
        this.updateStats();
        this.checkCompletion();
    }

    findNextStackPosition() {
        // First try to find a stack with only 1 tile (to complete it)
        for (let i = 0; i < 19; i++) {
            if (this.wallPositions[i] === 1) {
                return i;
            }
        }

        // If no incomplete stacks, find the first empty stack
        for (let i = 0; i < 19; i++) {
            if (this.wallPositions[i] === 0) {
                return i;
            }
        }

        return -1; // No available positions
    }

    updateStats() {
        const remaining = this.totalTiles - this.tilesPlaced;
        
        MahjongUtils.updateStats({
            'tilesRemaining': remaining,
            'stacksBuilt': this.stacksBuilt,
            'tilesPlaced': this.tilesPlaced
        });
    }

    checkCompletion() {
        if (this.tilesPlaced === this.tilesPerWall) {
            MahjongUtils.showCompletion('completionMessage');
        }
    }

    showHint() {
        const hints = [
            `You need exactly ${this.tilesPerWall} tiles to build your wall (${this.stacksPerWall} stacks Ã— 2 tiles high)`,
            "Drag tiles to different positions along your wall to create stacks",
            "Each stack needs exactly 2 tiles - one on bottom, one on top",
            `Stacks completed: ${this.stacksBuilt}/${this.stacksPerWall}`,
            `Tiles placed: ${this.tilesPlaced}/${this.tilesPerWall}`,
            "Try to spread tiles evenly across all 19 stack positions",
            "Drop tiles anywhere in 'Your Wall' and they'll find the next available spot!"
        ];

        const randomHint = hints[Math.floor(Math.random() * hints.length)];
        MahjongUtils.showHint(randomHint);
    }

    autoComplete() {
        // Get all remaining tiles from the center
        const remainingTiles = document.querySelectorAll('#tileCenter .mahjong-tile');

        // Place tiles systematically
        remainingTiles.forEach(tile => {
            if (this.tilesPlaced < this.tilesPerWall) {
                const stackIndex = this.findNextStackPosition();

                // Place the tile if we found a position
                if (stackIndex !== -1) {
                    const wallArea = document.getElementById('bottomWall');
                    const isTopTile = this.wallPositions[stackIndex] === 1;

                    // Position the tile
                    const x = 10 + (stackIndex * 30);
                    const y = isTopTile ? 10 : 30;

                    wallArea.appendChild(tile);
                    tile.style.position = 'absolute';
                    tile.style.left = x + 'px';
                    tile.style.top = y + 'px';
                    tile.classList.add('placed');
                    tile.draggable = false;

                    if (isTopTile) {
                        tile.classList.add('stacked');
                    }

                    this.wallPositions[stackIndex]++;
                    this.tilesPlaced++;
                }
            }
        });

        // Update stats and check completion
        this.stacksBuilt = this.wallPositions.filter(count => count === 2).length;
        this.updateStats();
        this.checkCompletion();
    }

    reset() {
        // Remove all existing event listeners to prevent duplicates
        MahjongUtils.removeDragAndDrop(this.dragHandlers);

        // Reset all game state
        this.tilesPlaced = 0;
        this.stacksBuilt = 0;
        this.wallPositions = Array(19).fill(0);
        document.getElementById('completionMessage').style.display = 'none';

        // Clear the bottom wall of any placed tiles
        const bottomWall = document.getElementById('bottomWall');
        bottomWall.innerHTML = '';

        // Completely reinitialize
        this.init();
    }
}

// Initialize the game when the page loads
const game = new MahjongWallGame();
</script>